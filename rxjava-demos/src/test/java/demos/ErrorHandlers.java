package demos;

import io.reactivex.rxjava3.core.Observable;
import org.junit.Before;
import org.junit.Test;

import java.util.concurrent.atomic.AtomicInteger;

@SuppressWarnings("ResultOfMethodCallIgnored")
public class ErrorHandlers {
  Observable<Integer> numbers;
  Observable<String> letters;

  @Before
  public void setUp() {
    numbers = Observable.range(1, 10);
    letters = Observable.just("a", "b", "c", "d", "e", "f", "g");
  }

  @Test
  public void doOnErrorTest() {
    System.out.println("======================================================");
    System.out.println("= doOnError operator");
    System.out.println("======================================================");
    numbers.map(i -> {
             if (i % 5 != 0) {
               return i;
             } else {
               throw new Exception("Divisible by five!");
             }
           })
           .doOnError(e -> System.err.println("Caught in doOnError..."))
           .subscribe(System.out::println, System.err::println);
  }

  @Test
  public void onErrorCompleteTest() {
    // Swallows errors, any error triggers onComplete
    System.out.println("======================================================");
    System.out.println("= onErrorComplete operator");
    System.out.println("======================================================");
    numbers.map(i -> {
             if (i % 5 != 0) {
               return i;
             } else {
               throw new Exception("Divisible by " + "five!");
             }
           })
           .doOnError(e -> System.out.println("*** secret error message ***"))
           .onErrorComplete()
           .subscribe(System.out::println,
                      e -> System.err.println("Should never reach here"),
                      () -> System.out.println("We're done here."));

  }

  @Test
  public void onErrorResumeNextTest() {
    // On error, resume with the value proved by the Function provided
    // Use onErrorResumeWith(Observable o) to provide an Observable directly
    System.out.println("======================================================");
    System.out.println("= onErrorResumeNext operator");
    System.out.println("======================================================");
    AtomicInteger index = new AtomicInteger(0);
    numbers
      .doOnNext((i) -> index.getAndIncrement() )
      .map(i -> {
             if (i % 5 != 0) {
               return i;
             } else {
               throw new Exception("Divisible by  five!");
             }
           })
           .onErrorResumeNext((e) -> numbers.skip(index.get()))
           .subscribe(System.out::println,
                      e -> System.err.println("Should never reach here"),
                      () -> System.out.println("We're done here."));

  }

  @Test
  public void onErrorReturnTest() {
    // If something goes wrong, return this instead (generated by a Function)
    // ...and complete!
    System.out.println("===== onErrorReturnNext =====");
    numbers.map(i -> {
             if (i % 5 != 0) {
               return i;
             } else {
               throw new Exception("Divisible by five!");
             }
           })
           .onErrorReturn((e) -> -1)
           .subscribe(System.out::println,
                      e -> System.err.println("Should never " + "reach here"),
                      () -> System.out.println("We're done here."));

  }

  @Test
  public void onErrorReturnItemTest() {
    // If something goes wrong, have this instead (static value)
    System.out.println("===== onErrorReturnItem =====");
    numbers.map(i -> {
             if (i % 5 != 0) {
               return i;
             } else {
               throw new Exception("Divisible by " + "five!");
             }
           })
           .onErrorReturnItem(-1)
           .subscribe(System.out::println,
                      e -> System.err.println("Should never " + "reach here"),
                      () -> System.out.println("We're done here."));

  }
}
